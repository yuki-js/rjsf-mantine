"use strict";(self.webpackChunk_rjsf_docs=self.webpackChunk_rjsf_docs||[]).push([[2888],{876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1228:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7896),i=(n(2784),n(876));const r={},l="uiSchema",o={unversionedId:"api-reference/uiSchema",id:"version-3.2.1/api-reference/uiSchema",title:"uiSchema",description:"JSON Schema is limited for describing how a given data type should be rendered as a form input component. That's why this library introduces the concept of uiSchema.",source:"@site/versioned_docs/version-3.2.1/api-reference/uiSchema.md",sourceDirName:"api-reference",slug:"/api-reference/uiSchema",permalink:"/react-jsonschema-form/docs/version-3.2.1/api-reference/uiSchema",draft:!1,editUrl:"https://github.com/rjsf-team/react-jsonschema-form/tree/main/packages/docs/versioned_docs/version-3.2.1/api-reference/uiSchema.md",tags:[],version:"3.2.1",frontMatter:{},sidebar:"docs",previous:{title:"uiSchema Options for Semantic-UI",permalink:"/react-jsonschema-form/docs/version-3.2.1/api-reference/themes/semantic-ui/uiSchema"},next:{title:"Usage and Customization",permalink:"/react-jsonschema-form/docs/version-3.2.1/usage/"}},s={},p=[{value:"classNames",id:"classnames",level:2},{value:"autofocus",id:"autofocus",level:2},{value:"description",id:"description",level:2},{value:"disabled",id:"disabled",level:2},{value:"enumDisabled",id:"enumdisabled",level:2},{value:"help",id:"help",level:2},{value:"inputType",id:"inputtype",level:2},{value:"label",id:"label",level:2},{value:"order",id:"order",level:2},{value:"placeholder",id:"placeholder",level:2},{value:"readonly",id:"readonly",level:2},{value:"rootFieldId",id:"rootfieldid",level:2},{value:"rows",id:"rows",level:2},{value:"title",id:"title",level:2},{value:"Theme Options",id:"theme-options",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"uischema"},"uiSchema"),(0,i.kt)("p",null,"JSON Schema is limited for describing how a given data type should be rendered as a form input component. That's why this library introduces the concept of uiSchema."),(0,i.kt)("p",null,"A UI schema is basically an object literal providing information on ",(0,i.kt)("strong",{parentName:"p"},"how")," the form should be rendered, while the JSON schema tells ",(0,i.kt)("strong",{parentName:"p"},"what"),"."),(0,i.kt)("p",null,"The uiSchema object follows the tree structure of the form field hierarchy, and defines how each property should be rendered."),(0,i.kt)("p",null,"Note that every property within uiSchema can be rendered in one of two ways: ",(0,i.kt)("inlineCode",{parentName:"p"},'{"ui:options": {[property]: [value]}}'),", or ",(0,i.kt)("inlineCode",{parentName:"p"},'{"ui:[property]": value}'),"."),(0,i.kt)("p",null,"In other words, the following uiSchemas are equivalent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "ui:title": "Title",\n  "ui:description": "Description"\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "ui:options": {\n    "title": "Title",\n    "description": "Description"\n  }\n}\n')),(0,i.kt)("h2",{id:"classnames"},"classNames"),(0,i.kt)("p",null,"The uiSchema object accepts a ",(0,i.kt)("inlineCode",{parentName:"p"},"classNames")," property for each field of the schema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const uiSchema = {\n  title: {\n    classNames: "task-title foo-bar"\n  }\n};\n')),(0,i.kt)("p",null,"Will result in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<div class="field field-string task-title foo-bar" >\n  <label>\n    <span>Title*</span>\n    <input value="My task" required="" type="text">\n  </label>\n</div>\n')),(0,i.kt)("h2",{id:"autofocus"},"autofocus"),(0,i.kt)("p",null,"If you want to automatically focus on a text input or textarea input, set the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:autofocus")," uiSchema directive to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:widget": "textarea",\n  "ui:autofocus": true\n}\n')),(0,i.kt)("h2",{id:"description"},"description"),(0,i.kt)("p",null,"Sometimes it's convenient to change the description of a field. This is the purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:description")," uiSchema directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:widget": "password",\n  "ui:description": "The best password"\n};\n')),(0,i.kt)("h2",{id:"disabled"},"disabled"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:disabled")," uiSchema directive will disable all child widgets from a given field."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: If you're wondering about the difference between a ",(0,i.kt)("inlineCode",{parentName:"p"},"disabled")," field and a ",(0,i.kt)("inlineCode",{parentName:"p"},"readonly")," one: Marking a field as read-only will render it greyed out, but its text value will be selectable. Disabling it will prevent its value to be selected at all.")),(0,i.kt)("h2",{id:"enumdisabled"},"enumDisabled"),(0,i.kt)("p",null,"To disable an option, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"enumDisabled")," property in uiSchema."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {\n  type: "string",\n  enum: ["one", "two", "three"],\n};\n\nconst uiSchema={\n  "ui:enumDisabled": [\'two\'],\n}\n')),(0,i.kt)("h2",{id:"help"},"help"),(0,i.kt)("p",null,"Sometimes it's convenient to add text next to a field to guide the end user filling it. This is the purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:help")," uiSchema directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:widget": "password",\n  "ui:help": "Hint: Make it strong!"\n};\n')),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://i.imgur.com/scJUuZo.png",alt:null})),(0,i.kt)("p",null,"Help texts work for any kind of field at any level, and will always be rendered immediately below the field component widget(s) (after contextualized errors, if any)."),(0,i.kt)("h2",{id:"inputtype"},"inputType"),(0,i.kt)("p",null,"To change the input type (for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"tel")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"email"),") you can specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"inputType")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:options")," uiSchema directive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:options": {\n    inputType: \'tel\'\n  }\n};\n')),(0,i.kt)("h2",{id:"label"},"label"),(0,i.kt)("p",null,"Field labels are rendered by default. Labels may be omitted by setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"label")," option to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:options")," uiSchema directive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:options": {\n    label: false\n  }\n};\n\nrender((\n  <Form schema={schema} uiSchema={uiSchema} />\n), document.getElementById("app"));\n')),(0,i.kt)("h2",{id:"order"},"order"),(0,i.kt)("p",null,"This property allows you to reorder the properties that are shown for a particular object. See ",(0,i.kt)("a",{parentName:"p",href:"/react-jsonschema-form/docs/version-3.2.1/usage/objects"},"Objects")," for more information."),(0,i.kt)("h2",{id:"placeholder"},"placeholder"),(0,i.kt)("p",null,"You can add placeholder text to an input by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:placeholder")," uiSchema directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const schema = {type: "string", format: "uri"};\nconst uiSchema = {\n  "ui:placeholder": "http://"\n};\n\nrender((\n  <Form schema={schema} uiSchema={uiSchema} />\n), document.getElementById("app"));\n')),(0,i.kt)("p",null,"Fields using ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:placeholder"),". The value will be used as the text for the empty option in the select widget."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const schema = {type: "string", enum: ["First", "Second"]};\nconst uiSchema = {\n  "ui:placeholder": "Choose an option"\n};\n\nrender((\n  <Form schema={schema} uiSchema={uiSchema} />\n), document.getElementById("app"));\n')),(0,i.kt)("h2",{id:"readonly"},"readonly"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:readonly")," uiSchema directive will mark all child widgets from a given field as read-only. This is equivalent to setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"readOnly")," property in the schema."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: If you're wondering about the difference between a ",(0,i.kt)("inlineCode",{parentName:"p"},"disabled")," field and a ",(0,i.kt)("inlineCode",{parentName:"p"},"readonly")," one: Marking a field as read-only will render it greyed out, but its text value will be selectable. Disabling it will prevent its value to be selected at all.")),(0,i.kt)("h2",{id:"rootfieldid"},"rootFieldId"),(0,i.kt)("p",null,"By default, this library will generate ids unique to the form for all rendered widgets. If you plan on using multiple instances of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Form")," component in a same page, it's wise to declare a root prefix for these, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:rootFieldId")," uiSchema directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const uiSchema = {\n  "ui:rootFieldId": "myform"\n};\n')),(0,i.kt)("p",null,"This will make all widgets have an id prefixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"myform"),"."),(0,i.kt)("h2",{id:"rows"},"rows"),(0,i.kt)("p",null,"You can set the initial height of a textarea widget by specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"rows")," option."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:widget": "textarea",\n  "ui:options": {\n    rows: 15\n  }\n};\n\nrender((\n  <Form schema={schema} uiSchema={uiSchema} />\n), document.getElementById("app"));\n')),(0,i.kt)("h2",{id:"title"},"title"),(0,i.kt)("p",null,"Sometimes it's convenient to change a field's title. This is the purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ui:title")," uiSchema directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const schema = {type: "string"};\nconst uiSchema = {\n  "ui:widget": "password",\n  "ui:title": "Your password"\n};\n')),(0,i.kt)("h2",{id:"theme-options"},"Theme Options"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/react-jsonschema-form/docs/version-3.2.1/api-reference/themes/semantic-ui/uiSchema"},"Semantic UI")))}d.isMDXComponent=!0}}]);