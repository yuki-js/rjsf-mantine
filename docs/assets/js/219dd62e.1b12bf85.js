"use strict";(self.webpackChunk_rjsf_docs=self.webpackChunk_rjsf_docs||[]).push([[7481],{876:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(2784);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),m=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=m(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=m(a),u=r,h=p["".concat(l,".").concat(u)]||p[u]||c[u]||o;return a?n.createElement(h,i(i({ref:t},d),{},{components:a})):n.createElement(h,i({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var m=2;m<o;m++)i[m]=a[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3217:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var n=a(7896),r=(a(2784),a(876));const o={},i="Validation",s={unversionedId:"usage/validation",id:"usage/validation",title:"Validation",description:"When the form is submitted, the form data is validated to conform to the given JSON schema;",source:"@site/docs/usage/validation.md",sourceDirName:"usage",slug:"/usage/validation",permalink:"/react-jsonschema-form/docs/usage/validation",draft:!1,editUrl:"https://github.com/rjsf-team/react-jsonschema-form/tree/main/packages/docs/docs/usage/validation.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Themes",permalink:"/react-jsonschema-form/docs/usage/themes"},next:{title:"Widgets",permalink:"/react-jsonschema-form/docs/usage/widgets"}},l={},m=[{value:"API documentation",id:"api-documentation",level:2},{value:"Precompiled validators",id:"precompiled-validators",level:2},{value:"Schema precompilation",id:"schema-precompilation",level:3},{value:"Using the precompiled validator",id:"using-the-precompiled-validator",level:3},{value:"Dynamically pre-compiling validators",id:"dynamically-pre-compiling-validators",level:3},{value:"Live validation",id:"live-validation",level:2},{value:"Validate form programmatically",id:"validate-form-programmatically",level:2},{value:"HTML5 Validation",id:"html5-validation",level:2},{value:"Custom validation rules",id:"custom-validation-rules",level:2},{value:"Custom error messages",id:"custom-error-messages",level:2},{value:"Error List Display",id:"error-list-display",level:2},{value:"The case of empty strings",id:"the-case-of-empty-strings",level:2},{value:"Custom meta schema validation",id:"custom-meta-schema-validation",level:2},{value:"additionalMetaSchemas",id:"additionalmetaschemas",level:3},{value:"customFormats",id:"customformats",level:3},{value:"Async validation",id:"async-validation",level:3},{value:"ajvOptionsOverrides",id:"ajvoptionsoverrides",level:3},{value:"Using the raw Ajv instance",id:"using-the-raw-ajv-instance",level:2},{value:"Ajv8 validator differences",id:"ajv8-validator-differences",level:2},{value:"ajvFormatOptions",id:"ajvformatoptions",level:3},{value:"AjvClass",id:"ajvclass",level:3},{value:"Localization (L12n) support",id:"localization-l12n-support",level:3},{value:"Some examples",id:"some-examples",level:4}],d={toc:m},p="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"validation"},"Validation"),(0,r.kt)("p",null,"When the form is submitted, the form data is validated to conform to the given JSON schema;"),(0,r.kt)("p",null,"As of version 5, as a result of decoupling the validation implementation from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"validator")," implementation is required to be passed to all ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),"s.\nReact Json Schema Form provides a default ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv6")," implementation that uses version 6 of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv"},"ajv")," validator."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: The ajv6 validator has been deprecated from the outset in favor of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," and is provided primarily to assist in code migrations")),(0,r.kt)("p",null,"It also provides a new ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," implementation that uses version 8 of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv"},"ajv")," validator.\nThe error messages generated by this new validator differ from those provided by the original validator due to it using a newer version.\nIf you depend on having specifically formatted messages, then using this validator would constitute a breaking change for you."),(0,r.kt)("p",null,"It is also possible for you to provide your own implementation if you desire, as long as it fulfills the ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidatorType")," interface specified in ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/utils"),"."),(0,r.kt)("h2",{id:"api-documentation"},"API documentation"),(0,r.kt)("p",null,"The documentation for the APIs associated with the AJV 8 validator package can be found ",(0,r.kt)("a",{parentName:"p",href:"/react-jsonschema-form/docs/api-reference/validator-ajv8"},"here")),(0,r.kt)("h2",{id:"precompiled-validators"},"Precompiled validators"),(0,r.kt)("p",null,"In 5.7.0, support for precompiled validators was added to the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," package.\nThe main use case for this is to overcome issues with ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe-eval")," warnings from the browser caused by strict Content Security Policy settings.\nSee the ",(0,r.kt)("a",{parentName:"p",href:"https://ajv.js.org/standalone.html"},"Standalone Validation Code")," section of the AJV documentation for more details about precompiled validators."),(0,r.kt)("p",null,"Due to how RJSF uses the AJV validator in determining ",(0,r.kt)("inlineCode",{parentName:"p"},"anyOf/oneOf")," selections and how it resolves dependencies, if-then-else and references ($ref) in schemas via the ",(0,r.kt)("inlineCode",{parentName:"p"},"retrieveSchema()")," utility method, RJSF provides its own schema compilation API built on-top-of the one provided by AJV 8.\nIf you are wanting to use a precompiled validator, two steps are required:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Precompiling the schema into a set of validator functions"),(0,r.kt)("li",{parentName:"ol"},"Providing those precompiled validator functions to a ",(0,r.kt)("inlineCode",{parentName:"li"},"ValidatorType")," implementation in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Form"))),(0,r.kt)("h3",{id:"schema-precompilation"},"Schema precompilation"),(0,r.kt)("p",null,"The first step in the process is to compile a schema into a set of validator functions that are saved into a commonJS-based Javascript file.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," package exports the ",(0,r.kt)("inlineCode",{parentName:"p"},"compileSchemaValidators()")," function that does this.\nIt is expected that this function will be used in a manner similar to the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cjs"},"const { compileSchemaValidators } = require('@rjsf/validator-ajv8');\nconst yourSchema = require('path_to/yourSchema'); // If your schema is a js file\n\ncompileSchemaValidators(yourSchema, 'path_to/yourCompiledSchema.js');\n")),(0,r.kt)("p",null,"If you are currently using the ",(0,r.kt)("inlineCode",{parentName:"p"},"customizeValidator()")," function to provide ",(0,r.kt)("inlineCode",{parentName:"p"},"additionalMetaSchemas"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"customFormats"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ajvOptionsOverrides")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"ajvFormatOptions")," then you can pass those in as the optional third parameter to the ",(0,r.kt)("inlineCode",{parentName:"p"},"compileSchemaValidators()")," function in a manner similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cjs"},"const { compileSchemaValidators } = require('@rjsf/validator-ajv8');\nconst yourSchema = require('path_to/yourSchema.json'); // If your schema is a json file\n\nconst options = {\n  additionalMetaSchemas: [require('ajv/lib/refs/json-schema-draft-06.json')],\n  customFormats: { 'phone-us': /\\(?\\d{3}\\)?[\\s-]?\\d{3}[\\s-]?\\d{4}$/, 'area-code': /\\d{3}/ },\n  ajvOptionsOverrides: {\n    $data: true,\n    verbose: true,\n  },\n  ajvFormatOptions: {\n    mode: 'fast',\n  },\n};\n\ncompileSchemaValidators(yourSchema, 'path_to/yourCompiledSchema.js', options);\n")),(0,r.kt)("p",null,"It is highly recommended to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"compileYourSchema.js")," file (or what ever name you want) with code similar to what is shown above and then, using node, run the code as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"node compileYourSchema.js\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: You must have your schema provided within a file that can be parsed and turned into the set of precompiled validator functions.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Additional Note: If you are using Webpack or NextJS and are encountering an issue resolving ",(0,r.kt)("inlineCode",{parentName:"p"},"fs")," during development, consult this ",(0,r.kt)("a",{parentName:"p",href:"https://bobbyhadz.com/blog/module-not-found-cant-resolve-fs"},"blog post")," for how to solve the issue.")),(0,r.kt)("h3",{id:"using-the-precompiled-validator"},"Using the precompiled validator"),(0,r.kt)("p",null,"After you have completed step 1 having generated your precompiled schema functions into the ",(0,r.kt)("inlineCode",{parentName:"p"},"yourCompiledSchema.js")," output file (or whatever you called it), then you need to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"ValidatorType")," implementation from it to use in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," package exports the ",(0,r.kt)("inlineCode",{parentName:"p"},"createPrecompiledValidator()")," function for this.\nHere is an example of how to use your precompiled validator with your ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPrecompiledValidator, ValidatorFunctions } from '@rjsf/validator-ajv8';\nimport Form from '@rjsf/core'; // Or whatever theme you use\n\nimport yourSchema from 'path_to/yourSchema'; // This needs to be the same file that was precompiled\nimport * as precompiledValidator from 'path_to/yourCompiledSchema';\n\nconst validator = createPrecompiledValidator(precompiledValidator as ValidatorFunctions);\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("h3",{id:"dynamically-pre-compiling-validators"},"Dynamically pre-compiling validators"),(0,r.kt)("p",null,"For more advanced cases when schema needs to be precompiled on request - ",(0,r.kt)("inlineCode",{parentName:"p"},"compileSchemaValidatorsCode")," can be used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { compileSchemaValidatorsCode } from '@rjsf/validator-ajv8/dist/compileSchemaValidators';\n\nconst code = compileSchemaValidatorsCode(schema, options);\n")),(0,r.kt)("p",null,"For the most part it is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"compileSchemaValidators"),", but instead of writing the file - it returns generated code directly."),(0,r.kt)("p",null,"To use it on browser side - some modifications are needed to provide runtime dependencies in generated code needs to be provided."),(0,r.kt)("p",null,"Example implementation of it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import type { ValidatorFunctions } from '@rjsf/validator-ajv8';\n\nimport ajvRuntimeEqual from 'ajv/dist/runtime/equal';\nimport {\n  parseJson as ajvRuntimeparseJson,\n  parseJsonNumber as ajvRuntimeparseJsonNumber,\n  parseJsonString as ajvRuntimeparseJsonString,\n} from 'ajv/dist/runtime/parseJson';\nimport ajvRuntimeQuote from 'ajv/dist/runtime/quote';\n// import ajvRuntimeRe2 from 'ajv/dist/runtime/re2';\nimport ajvRuntimeTimestamp from 'ajv/dist/runtime/timestamp';\nimport ajvRuntimeUcs2length from 'ajv/dist/runtime/ucs2length';\nimport ajvRuntimeUri from 'ajv/dist/runtime/uri';\nimport * as ajvFormats from 'ajv-formats/dist/formats';\n\n// dependencies to replace in generated code, to be provided by at runtime\nconst validatorsBundleReplacements: Record<string, [string, unknown]> = {\n  // '<code to be replaced>': ['<variable name to use as replacement>', <runtime dependency>],\n  'require(\"ajv/dist/runtime/equal\").default': ['ajvRuntimeEqual', ajvRuntimeEqual],\n  'require(\"ajv/dist/runtime/parseJson\").parseJson': ['ajvRuntimeparseJson', ajvRuntimeparseJson],\n  'require(\"ajv/dist/runtime/parseJson\").parseJsonNumber': ['ajvRuntimeparseJsonNumber', ajvRuntimeparseJsonNumber],\n  'require(\"ajv/dist/runtime/parseJson\").parseJsonString': ['ajvRuntimeparseJsonString', ajvRuntimeparseJsonString],\n  'require(\"ajv/dist/runtime/quote\").default': ['ajvRuntimeQuote', ajvRuntimeQuote],\n  // re2 by default is not in dependencies for ajv and so is likely not normally used\n  // 'require(\"ajv/dist/runtime/re2\").default': ['ajvRuntimeRe2', ajvRuntimeRe2],\n  'require(\"ajv/dist/runtime/timestamp\").default': ['ajvRuntimeTimestamp', ajvRuntimeTimestamp],\n  'require(\"ajv/dist/runtime/ucs2length\").default': ['ajvRuntimeUcs2length', ajvRuntimeUcs2length],\n  'require(\"ajv/dist/runtime/uri\").default': ['ajvRuntimeUri', ajvRuntimeUri],\n  // formats\n  'require(\"ajv-formats/dist/formats\")': ['ajvFormats', ajvFormats],\n};\n\nconst regexp = new RegExp(\n  Object.keys(validatorsBundleReplacements)\n    .map((key) => key.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'))\n    .join('|'),\n  'g'\n);\n\nfunction wrapAjvBundle(code: string) {\n  return `function(${Object.values(validatorsBundleReplacements)\n    .map(([name]) => name)\n    .join(', ')}){\\nvar exports = {};\\n${code.replace(\n    regexp,\n    (req) => validatorsBundleReplacements[req][0]\n  )};\\nreturn exports;\\n}`;\n}\n\nconst windowValidatorOnLoad = '__rjsf_validatorOnLoad';\nconst schemas = new Map<\n  string,\n  { promise: Promise<ValidatorFunctions>; resolve: (result: ValidatorFunctions) => void }\n>();\nif (typeof window !== 'undefined') {\n  // @ts-ignore\n  window[windowValidatorOnLoad] = (loadedId: string, fn: (...args: unknown[]) => ValidatorFunctions) => {\n    const validator = fn(...Object.values(validatorsBundleReplacements).map(([, dep]) => dep));\n    let validatorLoader = schemas.get(loadedId);\n    if (validatorLoader) {\n      validatorLoader.resolve(validator);\n    } else {\n      throw new Error(`Unknown validator loaded id=\"${loadedId}\"`);\n    }\n  };\n}\n\n/**\n * Evaluate precompiled validator in browser using script tag\n * @param id Identifier to avoid evaluating the same code multiple times\n * @param code Code generated server side using `compileSchemaValidatorsCode`\n * @param nonce nonce attribute to be added to script tag (https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce#using_nonce_to_allowlist_a_script_element)\n */\nexport function evaluateValidator(id: string, code: string, nonce: string): Promise<ValidatorFunctions> {\n  let maybeValidator = schemas.get(id);\n  if (maybeValidator) return maybeValidator.promise;\n  let resolveValidator: (result: ValidatorFunctions) => void;\n  const validatorPromise = new Promise<ValidatorFunctions>((resolve) => {\n    resolveValidator = resolve;\n  });\n  schemas.set(id, {\n    promise: validatorPromise,\n    resolve: resolveValidator!,\n  });\n\n  const scriptElement = document.createElement('script');\n\n  scriptElement.setAttribute('nonce', nonce);\n  scriptElement.text = `window[\"${windowValidatorOnLoad}\"](\"${id}\", ${wrapAjvBundle(code)})`;\n\n  document.body.appendChild(scriptElement);\n  return validatorPromise;\n}\n")),(0,r.kt)("p",null,"From React component this can be used as following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"let [precompiledValidator, setPrecompiledValidator] = React.useState<ValidatorFunctions>();\nReact.useEffect(() => {\n  evaluateValidator(\n    schemaId, // some schema id to avoid evaluating it multiple times\n    code, // result of compileSchemaValidatorsCode returned from the server\n    nonce // nonce script tag attribute to allow this ib content security policy for the page\n  ).then(setPrecompiledValidator);\n}, [entityType.id]);\n\nif (!precompiledValidator) {\n  // render loading screen\n}\nconst validator = createPrecompiledValidator(precompiledValidator, schema);\n")),(0,r.kt)("h2",{id:"live-validation"},"Live validation"),(0,r.kt)("p",null,"By default, form data are only validated when the form is submitted or when a new ",(0,r.kt)("inlineCode",{parentName:"p"},"formData")," prop is passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component."),(0,r.kt)("p",null,"You can enable live form data validation by passing a ",(0,r.kt)("inlineCode",{parentName:"p"},"liveValidate")," prop to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component, and set it to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),". Then, every time a value changes within the form data tree (e.g. the user entering a character in a field), a validation operation is performed, and the validation results are reflected into the form state."),(0,r.kt)("p",null,"Be warned that this is an expensive strategy, with possibly strong impact on performances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: ['string'],\n  const: 'test',\n};\n\nconst formData = 'a';\n\nrender(<Form schema={schema} formData={formData} validator={validator} liveValidate />, document.getElementById('app'));\n")),(0,r.kt)("h2",{id:"validate-form-programmatically"},"Validate form programmatically"),(0,r.kt)("p",null,"It is possible to programmatically validate a form using the ",(0,r.kt)("inlineCode",{parentName:"p"},"validateForm()")," function on ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),".\nAdd a ",(0,r.kt)("inlineCode",{parentName:"p"},"ref")," to your ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"validateForm()")," method to validate the form programmatically.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"validateForm()")," method returns true if the form is valid, false otherwise.\nIf you have provided an ",(0,r.kt)("inlineCode",{parentName:"p"},"onError")," callback it will be called with the list of errors when the ",(0,r.kt)("inlineCode",{parentName:"p"},"validatorForm()")," method returns false."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createRef } from 'react';\nimport { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst formRef = createRef();\nconst onError = (errors) => alert(errors);\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nrender(<Form schema={schema} validator={validator} onError={onError} ref={formRef} />, document.getElementById('app'));\n\nif (formRef.current.validateForm()) {\n  alert('Form is valid');\n}\n")),(0,r.kt)("h2",{id:"html5-validation"},"HTML5 Validation"),(0,r.kt)("p",null,"By default, the form uses HTML5 validation. This may cause unintuitive results because the HTML5 validation errors (such as when a field is ",(0,r.kt)("inlineCode",{parentName:"p"},"required"),") may be displayed before the form is submitted, and thus these errors will display differently from the react-jsonschema-form validation errors. You can turn off HTML validation by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"noHtml5Validate")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n  },\n};\n\nrender(<Form schema={schema} validator={validator} noHtml5Validate />, document.getElementById('app'));\n")),(0,r.kt)("h2",{id:"custom-validation-rules"},"Custom validation rules"),(0,r.kt)("p",null,"Form data is always validated against the JSON schema."),(0,r.kt)("p",null,"But it is possible to define your own custom validation rules that will run in addition to (and after) the ",(0,r.kt)("inlineCode",{parentName:"p"},"validator")," implementation.\nThis is especially useful when the validation depends on several interdependent fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nfunction customValidate(formData, errors, uiSchema) {\n  if (formData.pass1 !== formData.pass2) {\n    errors.pass2.addError(\"Passwords don't match\");\n  }\n  return errors;\n}\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    pass1: { type: 'string', minLength: 3 },\n    pass2: { type: 'string', minLength: 3 },\n  },\n};\n\nrender(<Form schema={schema} validator={validator} customValidate={customValidate} />, document.getElementById('app'));\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Notes:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"customValidate()")," function must implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"CustomValidator")," interface found in ",(0,r.kt)("inlineCode",{parentName:"li"},"@rjsf/utils"),"."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"customValidate()")," function must ",(0,r.kt)("strong",{parentName:"li"},"always")," return the ",(0,r.kt)("inlineCode",{parentName:"li"},"errors")," object received as second argument."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"customValidate()")," function is called ",(0,r.kt)("strong",{parentName:"li"},"after")," the JSON schema validation."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"customValidate()")," function is passed the ",(0,r.kt)("inlineCode",{parentName:"li"},"uiSchema")," as the third argument. This allows the ",(0,r.kt)("inlineCode",{parentName:"li"},"customValidate()")," function to be able to derive additional information from it for generating errors."))),(0,r.kt)("h2",{id:"custom-error-messages"},"Custom error messages"),(0,r.kt)("p",null,"Validation error messages are provided by the JSON Schema validation by default.\nIf you need to change these messages or make any other modifications to the errors from the JSON Schema validation, you can define a transform function that receives the list of JSON Schema errors and returns a new list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nfunction transformErrors(errors, uiSchema) {\n  return errors.map((error) => {\n    if (error.name === 'pattern') {\n      error.message = 'Only digits are allowed';\n    }\n    return error;\n  });\n}\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    onlyNumbersString: { type: 'string', pattern: '^\\\\d*$' },\n  },\n};\n\nrender(\n  <Form schema={schema} validator={validator} transformErrors={transformErrors} />,\n  document.getElementById('app')\n);\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Notes:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"transformErrors()")," function must implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ErrorTransformer")," interface found in ",(0,r.kt)("inlineCode",{parentName:"li"},"@rjsf/utils"),"."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"transformErrors()")," function must return the list of errors. Modifying the list in place without returning it will result in an error."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"transformErrors()")," function is passed the ",(0,r.kt)("inlineCode",{parentName:"li"},"uiSchema")," as the second argument. This allows the ",(0,r.kt)("inlineCode",{parentName:"li"},"transformErrors()")," function to be able to derive additional information from it for transforming errors."))),(0,r.kt)("p",null,"Each element in the ",(0,r.kt)("inlineCode",{parentName:"p"},"errors")," list passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"transformErrors")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"RJSFValidationError")," interface (in ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/utils"),") and has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"name"),': optional name of the error, for example, "required" or "minLength"'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"message"),': optional message, for example, "is a required property" or "should NOT be shorter than 3 characters"'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"params"),": optional object with the error params returned by ajv (",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ajv-validator/ajv/tree/6a671057ea6aae690b5967ee26a0ddf8452c6297#error-parameters"},"see doc")," for more info)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"property"),": optional string in Javascript property accessor notation to the data path of the field with the error. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},".name")," or ",(0,r.kt)("inlineCode",{parentName:"li"},".first-name"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"schemaPath"),": optional JSON pointer to the schema of the keyword that failed validation. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"#/fields/firstName/required"),". (Note: this may sometimes be wrong due to a ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ajv-validator/ajv/issues/512"},"bug in ajv"),")."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"stack"),': full error name, for example ".name is a required property".')),(0,r.kt)("h2",{id:"error-list-display"},"Error List Display"),(0,r.kt)("p",null,"To take control over how the form errors are displayed, you can define an ",(0,r.kt)("em",{parentName:"p"},"error list template")," for your form.\nThis list is the form global error list that appears at the top of your forms."),(0,r.kt)("p",null,"An error list template is basically a React stateless component being passed errors as props, so you can render them as you like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import { RJSFSchema, ErrorListProps } from "@rjsf/utils";\nimport validator from "@rjsf/validator-ajv8";\n\nfunction ErrorListTemplate(props: ErrorListProps) {\n  const { errors } = props;\n  return (\n    <div>\n      <h2>Custom error list</h2>\n      <ul>\n        {errors.map(error => (\n            <li key={error.stack}>\n              {error.stack}\n            </li>\n          ))}\n      </ul>\n    </div>\n  );\n}\n\nconst schema: RJSFSchema = {\n  type: "string",\n  const: "test"\n};\n\nrender((\n  <Form schema={schema}\n        validator={validator}\n        showErrorList=\'top\'\n        formData={""}\n        liveValidate\n        templates: {{ ErrorListTemplate }} />\n), document.getElementById("app"));\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: Your custom ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorList")," template will only render when ",(0,r.kt)("inlineCode",{parentName:"p"},"showErrorList")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"top")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"botttom"),".")),(0,r.kt)("p",null,"The following props are passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorList")," as defined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"ErrorListProps")," interface in ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/utils"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"errors"),": An array of the errors."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"errorSchema"),": The errorSchema constructed by ",(0,r.kt)("inlineCode",{parentName:"li"},"Form"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"schema"),": The schema that was passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"Form"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"uiSchema"),": The uiSchema that was passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"Form"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"formContext"),": The ",(0,r.kt)("inlineCode",{parentName:"li"},"formContext")," object that you passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"Form"),".")),(0,r.kt)("h2",{id:"the-case-of-empty-strings"},"The case of empty strings"),(0,r.kt)("p",null,"When a text input is empty, the field in form data is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),".\nHowever, since ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," isn't a valid JSON value according to ",(0,r.kt)("a",{parentName:"p",href:"https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf"},"the official JSON standard")," (ECMA-404, Section 5), the values get stored as ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"String fields that use ",(0,r.kt)("inlineCode",{parentName:"p"},"enum")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," widget will have an empty option at the top of the options list that when selected will result in the field being ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"One consequence of this is that if you have an empty string in your ",(0,r.kt)("inlineCode",{parentName:"p"},"enum")," array, selecting that option in the ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," input will cause the field to be set to ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", not an empty string."),(0,r.kt)("p",null,"If you want to have the field set to a default value when empty you can provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"ui:emptyValue")," field in the ",(0,r.kt)("inlineCode",{parentName:"p"},"uiSchema")," object."),(0,r.kt)("h2",{id:"custom-meta-schema-validation"},"Custom meta schema validation"),(0,r.kt)("p",null,"To have your schemas validated against any other meta schema than draft-07 (the current version of ",(0,r.kt)("a",{parentName:"p",href:"http://json-schema.org/"},"JSON Schema"),"), make sure your schema has a ",(0,r.kt)("inlineCode",{parentName:"p"},"$schema")," attribute that enables the validator to use the correct meta schema.\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "$schema": "http://json-schema.org/draft-04/schema#",\n  ...\n}\n')),(0,r.kt)("p",null,"Note that react-jsonschema-form supports JSON Schema draft-07 by default.\nTo support additional meta schemas, you can create and pass to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component a customized ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8"),":"),(0,r.kt)("h3",{id:"additionalmetaschemas"},"additionalMetaSchemas"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"additionalMetaSchemas")," prop allows you to validate the form data against one (or more than one) JSON Schema meta schema, for example, JSON Schema draft-04.\nYou can import a meta schema as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const metaSchemaDraft04 = require('ajv/lib/refs/json-schema-draft-04.json');\n")),(0,r.kt)("p",null,"In this example ",(0,r.kt)("inlineCode",{parentName:"p"},"schema")," passed as props to ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component can be validated against draft-07 (default) and by draft-04 (added), depending on the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"$schema")," attribute."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv6';\n\nconst validator = customizeValidator({\n  additionalMetaSchemas: [metaSchemaDraft04],\n});\n\nconst schema: RJSFSchema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  type: 'string',\n};\n\nreturn <Form schema={schema} validator={validator} />;\n")),(0,r.kt)("p",null,"NOTE: This syntax works only for the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv6")," validator; if you only use the ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-04")," schema, and you want to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," you can do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport AjvDraft04 from 'ajv-draft-04';\n\nconst validator = customizeValidator({ AjvClass: AjvDraft04 });\n\nconst schema: RJSFSchema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  type: 'string',\n};\n\nreturn <Form schema={schema} validator={validator} />;\n")),(0,r.kt)("h3",{id:"customformats"},"customFormats"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.7"},"Pre-defined semantic formats")," are limited.\nreact-jsonschema-form adds two formats, ",(0,r.kt)("inlineCode",{parentName:"p"},"color")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"data-url"),", to support certain ",(0,r.kt)("a",{parentName:"p",href:"/react-jsonschema-form/docs/usage/widgets"},"alternative widgets"),".\nTo add formats of your own, you can create and pass to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form")," component a customized ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n  format: 'phone-us',\n};\n\nconst customFormats = {\n  'phone-us': /\\(?\\d{3}\\)?[\\s-]?\\d{3}[\\s-]?\\d{4}$/,\n};\n\nconst validator = customizeValidator({ customFormats });\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"Format values can be anything AJV's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv/tree/6a671057ea6aae690b5967ee26a0ddf8452c6297#addformatstring-name-stringregexpfunctionobject-format---ajv"},(0,r.kt)("inlineCode",{parentName:"a"},"addFormat")," method")," accepts."),(0,r.kt)("h3",{id:"async-validation"},"Async validation"),(0,r.kt)("p",null,"Handling async errors is an important part of many applications. Support for this is added in the form of the ",(0,r.kt)("inlineCode",{parentName:"p"},"extraErrors")," prop."),(0,r.kt)("p",null,"For example, a request could be made to some backend when the user submits the form. If that request fails, the errors returned by the backend should be formatted like in the following example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema, ErrorSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'object',\n  properties: {\n    foo: {\n      type: 'string',\n    },\n    candy: {\n      type: 'object',\n      properties: {\n        bar: {\n          type: 'string',\n        },\n      },\n    },\n  },\n};\n\nconst extraErrors: ErrorSchema = {\n  foo: {\n    __errors: ['some error that got added as a prop'],\n  },\n  candy: {\n    bar: {\n      __errors: ['some error that got added as a prop'],\n    },\n  },\n};\n\nrender(<Form schema={schema} validator={validator} extraErrors={extraErrors} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,'An important note is that these errors are "display only" and will not block the user from submitting the form again.'),(0,r.kt)("h3",{id:"ajvoptionsoverrides"},"ajvOptionsOverrides"),(0,r.kt)("p",null,"In version 5, with the advent of the decoupling of the validation implementation from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Form"),", it is now possible to provide additional options to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv")," instance used within ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8"),".\nFor instance, if you need more information from ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv")," about errors via the ",(0,r.kt)("inlineCode",{parentName:"p"},"verbose")," option, now you can turn it on!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n  format: 'phone-us',\n};\n\nconst ajvOptionsOverrides = {\n  verbose: true,\n};\n\nconst validator = customizeValidator({ ajvOptionsOverrides });\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("h2",{id:"using-the-raw-ajv-instance"},"Using the raw Ajv instance"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"customizeValidator()")," function returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"AJV8Validator")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"AJV6Validator")," depending on the library you use) implementation class, which has an internal raw ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv")," instance within it.\nIf you need to do some deep customization of the instance using any of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv")," libraries (like ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv-keywords"),"), you can do so using this raw instance as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { customizeValidator } from '@rjsf/validator-ajv6';\nimport ajvKeywords from 'ajv-keywords';\n\nconst validator = customizeValidator();\najvKeywords(validator.ajv, ['your-keyword']);\n\n// use your update validator with a `Form`\n")),(0,r.kt)("h2",{id:"ajv8-validator-differences"},"Ajv8 validator differences"),(0,r.kt)("p",null,"There are a few differences in configuring the Ajv 8 validator.\nFirst, there are many things to be aware of related to internal migration from Ajv 6 to 8; see the ",(0,r.kt)("a",{parentName:"p",href:"https://ajv.js.org/v6-to-v8-migration.html"},"migration guide")," for more information."),(0,r.kt)("p",null,"One big difference is that Ajv 8 dropped support for any JSON Schema version before draft-06.\nSo if your schema is using an older format, you have to either upgrade it or stick with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv6"),"."),(0,r.kt)("p",null,"Our implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," also utilizes Ajv's internal cache to avoid unnecessarily re-compiling schemas, which can be an expensive operation. The cache key is the schema ",(0,r.kt)("inlineCode",{parentName:"p"},"$id"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ajvOptionsOverrides")," for the Ajv 8 validator are the ones supported by that version and not the Ajv 6 validator.\nSecond, the data formats previously provided in Ajv 6 now need to be added explicitly using the ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv-formats")," package.\nA new ",(0,r.kt)("inlineCode",{parentName:"p"},"ajvFormatOptions")," option is available on the ",(0,r.kt)("inlineCode",{parentName:"p"},"customizeValidator()")," API to be able to configure this.\nAdditionally, a new ",(0,r.kt)("inlineCode",{parentName:"p"},"AjvClass")," option is available on the ",(0,r.kt)("inlineCode",{parentName:"p"},"customizeValidator()")," API to support using one of the other ",(0,r.kt)("a",{parentName:"p",href:"https://ajv.js.org/json-schema.html#json-schema-versions"},"JSON schema versions")," provided by Ajv 8 besides the ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-07")," default.\nFinally, the Ajv 8 validator supports the localization of error messages."),(0,r.kt)("h3",{id:"ajvformatoptions"},"ajvFormatOptions"),(0,r.kt)("p",null,"By default, ALL formats are being added to the default ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," that you get when you import it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport validator from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n  format: 'email',\n};\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"If you don't actually need any of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv-formats#formats"},"ajv-formats")," and want to reduce the memory footprint, then you can turn it off as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nconst validator = customizeValidator({ ajvFormatOptions: false });\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"If you only need some of them, you can pass any of the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv-formats#options"},"options")," to the formatter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n  format: 'date',\n};\n\nconst validator = customizeValidator({ ajvFormatOptions: ['date'] });\n// or\n// const validator = customizeValidator({ ajvFormatOptions: { mode: \"fast\", formats: [\"date\"], keywords: true } });\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("h3",{id:"ajvclass"},"AjvClass"),(0,r.kt)("p",null,"By default, the ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf/validator-ajv8")," uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-07")," schema version.\nIt is possible to use one of the other version it supports, like ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-2019-09")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-2020-12"),".\nNOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"draft-2020-12")," has breaking changes and hasn't been fully tested with ",(0,r.kt)("inlineCode",{parentName:"p"},"@rjsf"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport Ajv2019 from 'ajv/dist/2019';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n  format: 'date',\n};\n\nconst validator = customizeValidator({ AjvClass: Ajv2019 });\n// or\n// const validator = customizeValidator({ AjvClass: Ajv2020 });\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("h3",{id:"localization-l12n-support"},"Localization (L12n) support"),(0,r.kt)("p",null,"The Ajv 8 validator supports the localization of error messages using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajv-validator/ajv-i18n"},"ajv-i18n"),".\nIn addition, you may provide a custom solution by implementing a function that conforms to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Localizer")," interface if your language is not supported."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { ErrorObject } from 'ajv';\n/** The type describing a function that takes a list of Ajv `ErrorObject`s and localizes them\n */\nexport type Localizer = (errors?: null | ErrorObject[]) => void;\n")),(0,r.kt)("p",null,"NOTE: The ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv-i18n")," validators implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Localizer")," interface."),(0,r.kt)("h4",{id:"some-examples"},"Some examples"),(0,r.kt)("p",null,"Using a specific locale while including all of ",(0,r.kt)("inlineCode",{parentName:"p"},"ajv-i18n"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport localizer from 'ajv-i18n';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nconst validator = customizeValidator({}, localizer.it);\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"Using a specific locale minimizing the bundle size"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport spanishLocalizer from 'ajv-i18n/localize/es';\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nconst validator = customizeValidator({}, spanishLocalizer);\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"An example of a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"Localizer")," implementation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { RJSFSchema } from '@rjsf/utils';\nimport { customizeValidator } from '@rjsf/validator-ajv8';\nimport { ErrorObject } from 'ajv';\n\nfunction localize_ru(errors: null | ErrorObject[] = []) {\n  if (!(errors && errors.length)) return;\n  errors.forEach(function (error) {\n    let outMessage = '';\n\n    switch (error.keyword) {\n      case 'pattern': {\n        outMessage = '\u0434\u043e\u043b\u0436\u043d\u043e \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043e\u0431\u0440\u0430\u0437\u0446\u0443 \"' + error.params.pattern + '\"';\n        break;\n      }\n      case 'required': {\n        outMessage = '\u043f\u043e\u043b\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f';\n        break;\n      }\n      default:\n        outMessage = error.message;\n    }\n\n    error.message = outMessage;\n  });\n}\n\nconst schema: RJSFSchema = {\n  type: 'string',\n};\n\nconst validator = customizeValidator({}, localize_ru);\n\nrender(<Form schema={schema} validator={validator} />, document.getElementById('app'));\n")),(0,r.kt)("p",null,"NOTES:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you provided your own function, modify the list in place."),(0,r.kt)("li",{parentName:"ul"},"You must process all the cases which you need by yourself. See the full list of possible cases ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ajv-validator/ajv-i18n/blob/master/messages/index.js"},"here"),"."),(0,r.kt)("li",{parentName:"ul"},"Each element in the ",(0,r.kt)("inlineCode",{parentName:"li"},"errors")," list passed to the custom function represent a ",(0,r.kt)("strong",{parentName:"li"},"raw")," error object returned by ajv (",(0,r.kt)("a",{parentName:"li",href:"https://github.com/ajv-validator/ajv/blob/master/docs/api.md#error-objects"},"see doc"),").")))}c.isMDXComponent=!0}}]);